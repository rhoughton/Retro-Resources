micro all right I'm going to do another reading out of the issue #43 of micro cornucopia the name of this article is fast fractals programming the 386 under MS-DOS this is one of our trick articles the fractals are really just a sneaky way to get your attention after all how many of you would read an article about speeding up 386 software by a factor of 100 as excitement over the 386 dies down we're left with an uncomfortable feeling a 32 bit operating system one that will provide memory management over huge address spaces is a long way off and when it comes it will cost a lot but don't despair the 386 has many powerful features that can be used under a 16 bit operating system features that can give your programs a real kick this article shows how to use 32 bit instructions on the 386 under msdos as an example we'll turbocharge the familiar Mandelbrot zoom our 386 version will use fixed point math to obtain the equivalent of 1M flops which is million floating point operations per second without a math coprocessor consequently the program will take minutes not the usual hours or days to produce fractal diagrams like Figure 1 and don't worry guys you're not missing out on this particular picture and I remember an issue of micro cornucopia having this exact same picture on their front cover to show how simple the process is the program will be written for a 16 bit C compiler assembler that is a compiler slash assembler that doesn't understand 386 mnemonics I begin with an overview of 386 modes then move into a brief discussion of the Mandelbrot calculation and fixed point math to minimize repetition I'll assume you've read Larry Fogg's article on the Mandelbrot set which is in micro sees issue #39 and Earl Henricks article on fixed point micro CSU #41 another useful reference is the 83D6387 architecture by S Morris E Isaacson and D Albert modes the 386 has three modes rail protected and virtual real mode is the default or how the processor wakes up after you turn on the computer segments and real motors 16 bits long and there are no memory protection schemes when the 386 gets nudged into protected mode the segments can be 32 bits long allowing huge address spaces and all sorts of multitasking and memory protection features become available V8086 mode is very handy for running old 8086 applications within a multitasking operating system programs under V8086 behave very much like real mode programs and if it wasn't very clear The V stands for virtual in all modes it's possible to accept access 32 bit registers and use 32 bit instructions the 32 bit extensions of the familiar 8086 registers are called elax ebx ecx edx EDI OK so especially for anybody who's seen my older videos on the X86 architecture you're going to know the name of these registers the lower 16 bits of these registers can still be accessed as ax BX etc mdas is designed for real mode so that's the mode we'll use by default instructions in real mode operate on 8 or 16 bit quantities to use 32 bit operands and the instruction must be prefixed with an override byte 66 H for register operations and 67H for addressing and remember if you ever have any questions you can definitely leave them in the comments below for anyone who doesn't know H stands for hexadecimal so we're looking at a hexadecimal number there if you have a 386 assembler you won't have to worry about all the override bytes you can freely mix 16 bit and 32 bit instructions in the same assembly language program and he has assembler will automatically insert the overrides in the object code if you don't have a 386 assembler you can still use the 32 bit instructions by inserting DB66H before a 16 bit instruction normally DB defined byte is used in the data segment but most assemblers also allow DBS encode if there is no corresponding 16 bit instruction you can put the entire byte encoding for the operation after a DB for example to code the 386 instructions type out the assembly you're not missing much they are just showing the difference between through 86 instructions and a non 386 assembler written in non 386 assembly as well the first instruction is easy since the older 8086 processors have a 16 bit add that corresponds exactly to the 32 bit ad however we have to replace the shld with a byte encoding since the earlier processors had no double shift instructions byte encodings can be determined from any good 386 programming guide I don't know why word dictate didn't type exactly what I said schweid oh and they give us another interpretation why can't it just type the exact letters I say anyways the next section is called defined bytes there are good reasons for using the DB approach even if you have a 386 assembler for example it is often desirable to call an assembly language function from a high level language many compilers require that the function be assembled with a particular version of Microsoft's masm unfortunately masm puts a peculiar head on functions assembled specifically for 386 rail mode even if the function contains nothing but 8086 instructions the header is enough to confuse the heck out of non Microsoft linkers like the link method the DB approach circumvents the header problem since you have to tell the assembler that the module contains 386 code furthermore many C compilers come up with their own assemblers typically these assemblers can't understand 386 mnemonics so there's no alternative to the DB method. I've taken the DB approach in this article because it is the most general and because my favorite compiler is DeSmet C/asm88 OK I just typed that out rather than rely on Microsoft dictate so that's his favorite compiler which doesn't understand 386 mnemonics alright I'll skip the Mandelbrot calculations section there's a lot of math in there I'll jump to the section titled fixed point math one way to speed up the Mandelbrot calculations especially on computers that don't have floating point hardware for example a 8387 or 8287 math coprocessor is to substitute fixed point for floating point math this idea isn't new see for example the article by H Katz in doctor Dobbs journal November 1986  

Dr. Dobbs Journal?  

however the 386 has instructions that make fixed point math very easy and very fast fixed point numbers have an integer and a fractional portion separated by a conceptual binary point in our program we'll store fixed point numbers as 32 bit integers with the integer portion in the upper 8 bits and the fractional portion and the lower 24 bits thus the binary point is between bits 23 and 24 with this system we can represent positive or negative numbers with absolute values between 6 * 10 to the - 8 and 127.9999999 that range is fine for mandelbrot diagrams X&Y will never get too big because the calculation will stop if either XN to the two or Y N to the two exceeds 4 and it turns out that the regions of the diagram with both P&Q less than .25 are pretty uninteresting fixed point numbers are added subtracted and compared just like ordinary 32 bit integers but multiplication is slightly more complicated to calculate the fixed point product of X&Y we might try the C statement and then they show the formula in C he goes on to say that is the integer product X * y must be divided by two to the 24 he gives us the number that it equals and he says to get the correct fixed point product well you would access the value of the code he showed now he says there's a problem with this C code the product X * y could be 64 bits long which would cause overflow in most compiled code the problem disappears in assembly language hence most 32 bit processors have no trouble multiplying 32 bit numbers to form a 64 bit product for example suppose we have two fixed point numbers stored in the 386 registers eax and ebx  

to multiply these numbers and place the fixed point product and edx requires only two instructions 

Imul ebx  

Shld edx,eax,8 

type out the assembly code just note the beginning of those two lines should have lower case letters he goes on to say that I am UL laces the 64 bit product in the register pair edx:eax  

the high bits in edx and the double shift instruction adjusts the binary point we shift left by 8 bits instead of right by 24 bits because we want the product to end U in edx some programmers prefer fixed point with 16 bit integer and 16 bit fractional portions however as I've seen mandelbrot calculations done with the 16/ 16 format and the inaccuracies were pretty obvious even at most magnifications so that's a shameless issue isn't uploaded to the Internet at least not archive.org if you happen to find a link to this I'd appreciate it if you put it in the comments I'll go ahead and take a few pictures because I don't have a scanner but I'll take a picture of the three correction five blocks of code in this particular article and now I'll drum to the very end of the article where it's titled final words he says we barely skirted the 386 features you can use under MS-DOS we didn't cover advanced addressing modes nor all the powerful new instructions the 386 is full of goodies such as the BSF and BSR which stands for bit scan forward and bit scan reverse which makes software floating point fast and very easy it's important to explore the chip has so much potential it would be criminal to use the 386 as nothing more than a fast 286 instead of chewing your fingernails while Microsoft inflates OS2 a few more megabytes buy a few more megabytes start lacing your MS-DOS programs with high speed 32 bit instructions yes you're still stuck with the 16 bit segments but how many of your programs really need data structures larger than 64K probably very few and the O2 can't help you with that problem anyways when the protected mode operating system finally rolls around you'll be that much ahead of the pack and that's it thanks for watching 
