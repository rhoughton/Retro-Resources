Success in this field requires connections is the subtitle and this is written by Bruce eckel the editor introduces the article by saying asynchronous serial communication is definitely one of the weirder parts of personal computing although Rs 232 is a standard interface you can't just plug things together and expect them to work OK so now Bruce jumps in with in this article I'll discuss my strategy for cabling problems talk about RS232 on the IBM PC and its clones try to dispel some of the mystery of communications protocols and otherwise entertain you 

in serial communication you force all the information through a single wire one bit at a time sounds strange doesn't it instead of each bit in a bite having its own wire as on a parallel printer port each bit has to wait its turn on a single wire there are two methods for communicating serially synchronous and asynchronous and synchronous communication there are two signals data and clock because of the clock which tells the receiver receiving and when the next bit is valid there is no need to pause between bites to reset both the sender and receiver thus there are no stop or start bits in asynchronous communication by far the most common mode only the data is sent first both ends have to agree on how fast the data is sent the baud rate then there's pause between characters the start bit at the beginning of the character and the 1, 1.5 or 2 stop bits at the end 

by keeping track of the start and stop bits and by knowing how fast data is being sent the receiver knows when to look for each of the eight or seven data bits that come between figure one shows how a byte is transferred the ones and zeros are logical they don't reflect the voltage values on the RS232 lines so more about that later when quiet the line is in marking condition (its marking time) the first edge of the signal notifies the receiver that a new byte is beginning to ensure it wasn't just a noise glitch the receiving device the 8250 on a PC rechecks the signal by sampling it several times after the last data bit some extra information arrives if you have parity turned on then the 8250 adds a one or zero to make the number of 1 bits in the character even or odd  

if one of the bits was received incorrectly then the receiving end would notice that the number of ones was no longer correct if two bits changed then parity checking wouldn't catch the problem the stop bits arrive last you can use 11.5 or two the stop bits return the line to its marking state they allow the receiving system some time to take care of things before the next spike starts the most common configuration you'll probably use is 8 bits no parity one stop bit 

this means 10 bits are transmitted for each byte so if you divide your bit rate also known as baud rate where they should have just wrote bod by 10 the result will tell you approximately how many bytes per second you will move for example at 9600 bits per second you'll move approximately 960 bytes per second this number is only approximate since most file transfer protocols add bytes to the beginning and end of each data block after a byte has arrived the 8250 places it in a temporary storage register and sets some flags if there were unread bites in the register when the new one came in destroying the old one the overrun flag is set if parity is on And parity isn't right indicating a noise glitch on the line the 8250 sets the parity error flag if you have set U the system for interrupts this is performed in software by your communications program a received byte forces an interrupt then the interrupt service routine must grab the bite before it's overrun there are only three important wires in serial communication a line to transmit from a line to receive and a ground line you can transmit and receive at the same time the lines are completely independent you may notice there usually 25 pins on your serial connector that's more than three to understand why some history is in order so the EIA which stands for electronic industries association RS232C which stands for recommended standard 232C was developed solely to connect data terminal equipment also known as DTS which are computers terminals printers and other like machines O this standard was developed to connect these dtes to data communication equipment de that is a modem O it consists of the definition of a set of lines through which this communication takes place and the voltage levels for one and zeros through these lines the physical connection is most often made through either a deep B25 or DB9 connector check out the pinout and the line names and figure two I started this video by showing a picture so you could always go right back to that on RS232A transmit and receive lines pins two and three  

a logical 0 is represented by a signal between 5 and 15 volts A logical one is represented by a signal between - 5 and - 15 volts as you might guess there is also an RS232B it uses voltages between 25 and - 25 volts it's worth noting that the standard RS232 driver chip and receiver chip don't work reliably at Â± 5 volts the Commodore 64 contains simple transistor level shifters in place of these chips the calm adores RS232 interface doesn't work with all serial devices 

now the other handshake and clock lines on the RS232 interface uses the same voltage levels as the data lines but their senses backwards on these lines a positive voltage represents a logic one and a negative voltage represents a logic 0 signal generators assume they'll be driving 3K to 7K ohms thus they have to supply between 2:00 and 5:00 milliamps Miller most line drivers and receivers are capable of supplying between 10 and 20 OK and then he's going to go into cable length he says it's a tribute to human ingenuity to see how many non modem things people found to hang on to the RS232 he talks about another insidious line is clear to send CTS he'll talk about this the he'll talk about his second solution to the flow control problem Bing software he says the PC can access via the microprocessors address line memory cells or io cells IO addressing has different timing and handshaking than memory addressing IO devices generally respond more slowly than memory not all microprocessors do this the Motorola 68,000 family used in Macs ataris amigas and many Unix machines puts all of its IO in the memory space this is called memory mapped IO the 68,000 has special handshake lines for slow memory or peripherals the status pins on the 8086 or 8088 microprocessor tell the rest of the system whether the next access will be memory or io high level languages also have some method of specifying io turbo Pascal uses the port array turbo prolog uses the port byte predicate and Microsoft C uses inp() outp() 

OK and I typed it correctly there when a communication program attempts to transfer a large amount of data for instance a file over a serial link it runs a risk it's not unusual for noise or other problems to change bits as a cell across the line for file transfers to be dependable the transfer program must be able to determine whether there is an error and if so correct it most file transfer protocols break files up into blocks or packets this way you don't need to retransmit an entire file if there's an error data is usually surrounded by information which says a packet is coming this is its number here's the data one of the earliest micro computer protocols is ward christiansen's xmodem xmodem divides a file into packets containing 1 the state or the start of header character to indicate the beginning of a packet the sequence number of the packet both normal and its one complement 128 bytes of file data and one byte of checksum or the check value which is calculated by simply adding all the data bytes together as they come in throwing away the carries although by no means perfect X modem is probably the most commonly used protocol in early flaw A checksum can miss errors has re rectified with the addition of a cyclic redundancy check CRC for the check value CCRC's are more complicated but much more reliable but you must often specify X modem checksum or xmodem CRC The Y modem transfer has its own protocol but we'll use xmodem if that's what the other end is using modem WX modem and others keep popping up usually what's best is whatever the other machine uses I've looked at a number of domain shareware communications programs and I think my favorite is sharewares procomm it's mature it seems bug free it supports most popular file transfer protocols it emulates a Vt 100 terminal which is convenient for connecting to minis and mainframes and it's easy to use the only problem with most of these protocols is they were developed on micro computers so many of them can only be found on micro computers though xmodem is often found on Unix systems 

Columbia University set out to smash the communications protocol bug once and for all with Kermit which was designed to work on all computers without regard to size this was an ambitious project but it seems to work and it helps that all of the source code is public domain Kermit negotiates with the other end to establish the communication parameters this is clever since it allows extensions to the protocol without disturbing existing installations and then Bruce eckel will end this particular article by saying someday there's a lot more to writing a communication program than I can cover here he suggests we check out Joe Campbell 's superb C programmers guide to serial communication but he does plan to do some kind of experiment with it in the coming months so stay tuned thanks for watching 
